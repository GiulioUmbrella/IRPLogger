{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"File Operations Features","text":"<p>This guide provides a reference for parsing I/O operations in Microsoft OS. </p> <ul> <li> <p>IRPLogger describes the software used to capture operations.</p> </li> <li> <p>IRP Packet describes the structure of an IRP Packet.</p> </li> <li> <p>IRP Packet Parsing describes how to parse an IRP packet to extract the features.</p> </li> </ul>"},{"location":"irplogger/","title":"IRPLogger","text":"<p>The IRPLogger is software that extracts relevant features from file operations. It receives details of these operations, parses them, and saves the information to a log file. This page explains which parts of the IRPLogger must be modified to capture additional features or to alter existing ones.</p>"},{"location":"irplogger/#irplogger-structure","title":"IRPLogger structure","text":"<p>The IRPLogger consists of three components: a kernel module, a user module, and a custom data frame. The kernel (filter) module receives I/O operations, parses the contents, and saves them to a custom data frame. The user module then receives this frame and saves it to a file.</p> <p></p> <p>The main steps to add a feature are the following:</p> <ol> <li>Identify the feature of interest</li> <li>Add a rule in the filter module</li> <li>Modify the custom frame for storing additional information</li> <li>Modify the user module for printing the additional features</li> </ol> <p>To implement the modification it is sufficient to modify only the files related to these operations:</p> <ul> <li>IRPLogger/filter/IRPLoggerLog.c</li> <li>IRPLogger/user/IRPLoggerLog.c</li> <li>IRPLogger/inc/IRPLogger.h</li> </ul>"},{"location":"irplogger/#incirploggerh","title":"inc/IRPLogger.h","text":"<p>The inc/IRPLogger.h file defines a RECORD_DATA structure, which serves as a custom frame for collecting various parameters. To capture additional data, this structure can be extended with new variables. At runtime, the logger creates a new frame and provides a pointer to it for the filter to populate. For example, the major function code is defined as a UCHAR variable named callback_major_id.</p> <pre><code>typedef struct _RECORD_DATA {\n    //\n    UCHAR callback_major_id;\n    //\n} RECORD_DATA, *PRECORD_DATA;\n</code></pre>"},{"location":"irplogger/#filterirploggerlogc","title":"filter/IRPLoggerLog.c","text":"<p>The filter/IRPLoggerLog.c use a <code>record_data</code> variable of type <code>RECORD_DATA</code> to save the parameters. For example, to save the major function code, we can do the following:</p> <pre><code>record_data-&gt;callback_major_id = data-&gt;Iopb-&gt;MajorFunction;\n</code></pre> <p>The dereferencing of <code>data-&gt;Iopb-&gt;MajorFunction</code> variable is defined in the the IRP packet parsing page.</p> <p>For an incoming packet, the record_data structure can be modified either before or after the operation, depending on the nature of the operation. The functions <code>log_pre_operation_data</code> and <code>log_post_operation_data</code> access the data before and after the operation, respectively.</p> <p>Inside these two functions we can define specific filter depending on the IRP packet major function code:</p> <pre><code>if (record_data-&gt;callback_major_id == IRP_MJ_WRITE) {\n    // Specific rules for write operation\n}\n</code></pre> <p>If additional information needs to be extracted, we can proceed as follows:</p> <pre><code>// 1. Check major function code\nif (data-&gt;Iopb-&gt;MajorFunction == IRP_MJ_SET_INFORMATION)\n    {\n        // 2. Check FileInformationClass Value\n        if (data-&gt;Iopb-&gt;Parameters.SetFileInformation.FileInformationClass \n        == FileRenameInformation)\n        {\n            // 3. Get pointer to specific structure\n            PFILE_RENAME_INFORMATION renameInfo;\n            renameInfo = (PFILE_RENAME_INFORMATION)data-&gt;Iopb-&gt;Parameters.\n            SetFileInformation.InfoBuffer;\n            //...\n\n        }\n    }\n</code></pre> <p>The code example perform the following operations:</p> <ol> <li>Check the major function code.</li> <li>Verify the subcase using the <code>FileInformationClass</code> variable inside the specific struct.</li> <li>Obtain a pointer to the operation specific structure.</li> </ol>"},{"location":"irplogger/#userirploggerlogc","title":"/user/IRPLoggerLog.c","text":"<p>The user/IRPLoggerLog.c uses a <code>log_on_file</code> function to parse the  <code>RECORD_DATA</code> data frame and save it to a file.</p> <p>For example, for saving the type of operation we can do the following:</p> <pre><code>if (record_data-&gt;flags &amp; FLT_CALLBACK_DATA_IRP_OPERATION)\n    fprintf(file, \"IRP\");\n</code></pre> <p>In case of specific parameters, we can check the major function code:</p> <pre><code> if(record_data-&gt;callback_major_id == IRP_MJ_SET_INFORMATION) \n    {\n        fprintf(file, \"InfoClass: %X\\t\", record_data-&gt;x.FileRename.FileInformationClass);\n        // ...\n    }\n</code></pre> <p>The previous example saves the <code>FileInformationClass</code> value to file to detonate the subcase.</p>"},{"location":"irppacket/","title":"IRP Packet","text":"<p>This page provides an overview of how IRP packets are organized. The IRP packet parsing pages provides more the details on how to parse the packet for collecting features on file operations.</p> <p>Microsoft executes file operation using a common data structure called IRP packets. Processes cannot directly manipulate files, which are executed by the operating system. Behind the curtain, the OS packs all the relevant details in an IRP packet and sends it to device performing the operations. </p> <p>An IRP packer has two main components: a header and a stack location The header contains information for the operating system to send the packet in the proper way inside the system, while the stack contains the actual parameters for the operation. In this guide, we focus on the stack location has it contains the value or interest to record the operations.</p> IRP packet header and stack <p>The IRP packet is designed to minimize the amount of data to be transported; therefore, it contains several pointers to the appropriate data. For write operations, the packet includes a pointer to the buffer that will overwrite the original contents. For a file rename operations, the packet contains a pointer to the string with the new name.</p> Additional data for write operation (on the left) and rename operation (on the right)"},{"location":"irppacket/#irp-packet-stack-overview","title":"IRP Packet stack overview","text":"<p>The stack location has two main components: the major function code and the parameters. The stack may contains pointers to other structure or data; we provide more details in the next section. </p> IRP packet general structure <p>The Major function code is a unique identifier for the operation type. For example, for a write operation on a file, the Major function code is <code>IRP_MJ_WRITE</code>. The Microsoft documentation contains descriptions of the major function code and the operations they represents. </p> <p>The Parameters variable contains all the associated information for that specific operation. The <code>Parameters</code> variable is a union of different structures. Hence, the structure type changes accordingly to the type of the operation. For example, for a file write operation, the Parameters is a struct Write. Each structure contains the details of the operation. In the file write case, the structure contains the offset from the file start and number of bytes to write. </p> IRP packet for a write operation <p>So, each major function code has an associated structure packing the relevant contents Hence, it is necessary to know for each file operation the major function code / parameter type pair. The following table show some examples:</p> File Operation Major Function code Parameter type File write IRP_MJ_WRITE struct Write File read IRP_MJ_READ struct Read File rename IRP_MJ_SET_INFORMATION struct SetFileInformation <p>For a write file operation, the IRP packet has a major function code of IRP_MJ_WRITE, and the associated structure is named struct Write. Similarly, for a read file operation, the major function code is IRP_MJ_READ, with the associated structure being struct Read. Some major function codes cover several cases. For example, IRP_MJ_SET_INFORMATION is associated with the modification of file metadata, such as during a file rename operation. The next section provides additional information on these specific cases.</p>"},{"location":"irppacket/#irp-packet-additional-information","title":"IRP Packet additional information","text":"<p>As we saw above, the same IRP code may be associated to different type of operations, hence the packet needs to carry additional parameter. The specification is similar to the main IRP packet structure; a label specifies the nature of the parameters, a specialized struct carries them. </p> IRP packet with additional parameters <p>A <code>FileInformationClass</code> identifies the operation; the variable is defined as a <code>FILE_INFORMATION_CLASS</code> enumeration, listing all the of possibile additional information case. The additional parameters are packed in a specific structure. </p> <p>For example, the rename file operation uses this scheme.</p> <ul> <li>The associated MajorFunction code is IRP_MJ_SET_INFORMATION.</li> <li>The struct is the SetFileInformation. </li> <li>The FILE_INFORMATION_CLASS variable has value FileRenameInformation. </li> <li>The additional operations are stored in a struct name FILE_RENAME_OPERATION which contains a pointer to the new file name string.</li> </ul> IRP packet for a rename  operation"},{"location":"irppacket_parsing/","title":"IRP Packet Parsing","text":"<p>This page provides details on how to extract relevant features for file operations. Consulte the IRP Packet page for a reference on how IRP packets are organized and the IRPLogger for an overview of the software for collecting the features. </p>"},{"location":"irppacket_parsing/#parse-irp-packet","title":"Parse IRP Packet","text":"<p>The IRPLogger receives a <code>data</code> frame with a <code>FLT_CALLBACK_DATA</code> structure containing several elements. The most important is a pointer <code>PFLT_IO_PARAMETER_BLOCK Iopb</code>. The Iopb containts pointers to the IRP major function code and FLT_PARAMETERS.</p> <ol> <li>Determine the FileInformationClass value</li> <li>Cast the InfoPointer buffer to the </li> <li>Use the pointer</li> </ol> <p>The following code, extracted from filter/IRPLoggerLog.c, demonstrates how to parse a packet for delete operations. The primary function code used is IRP_MJ_SET_INFORMATION, with additional parameters stored in the FILE_DISPOSITION_INFORMATION structure. For more details, refer to the IRP packet page. Consider the following example for the deletion of a file:</p> <p><pre><code>    if (data-&gt;Iopb-&gt;MajorFunction == IRP_MJ_SET_INFORMATION)\n    {\n        int fileinformationclass;\n        fileinformationclass = data-&gt;Iopb-&gt;Parameters.SetFileInformation.FileInformationClass;\n        record_data-&gt;x.SetInformation.InfoTag = fileinformationclass;\n\n        if (fileinformationclass == FileDispositionInformation)\n        {\n            PFILE_DISPOSITION_INFORMATION ptr;\n            ptr = (PFILE_DISPOSITION_INFORMATION)data-&gt;Iopb-&gt;Parameters.SetFileInformation.InfoBuffer;\n            record_data-&gt;x.SetInformation.InfoClass.Delete = ptr-&gt;DeleteFile;\n        }\n  }\n</code></pre> The code performs the following operations:</p> <ol> <li>Check if the Major code is <code>IRP_MJ_SET_INFORMATION</code></li> <li>Verify if the fileinformationclass for the FileDispositionInformation. </li> <li>Declare a PFILE_DISPOSITION_INFORMATION pointer to FILE_DISPOSITION_INFORMATION struct</li> <li>Cast the InforBuffer to PFILE_DISPOSITION_INFORMATION </li> <li>Differentiate the pointer to access elements within the FILE_DISPOSITION_INFORMATION structure.</li> </ol>"},{"location":"irppacket_parsing/#list-of-features","title":"List of features","text":"<p>Total list of features use by the different model.</p> <ul> <li>Entropy              </li> <li>Similarity           </li> <li>Override ratio       </li> <li>Delete               </li> <li>File type cross Write</li> <li>File type cross R/W  </li> <li>File type Coverage   </li> <li>File type change     </li> <li>File Rename/Move     </li> <li>File size change     </li> <li>Access Frequency     </li> <li>File Create          </li> <li>File Read            </li> <li>File Write           </li> <li>File Close           </li> <li>Folder listing       </li> <li>Directory Traversal  </li> <li>Temporary Files      </li> </ul> <p>Some of them can be directly obtained by the logger. Other instead can be derived with some pre-processing operations.</p> <p>NB: select WHERE to capture the variation, in the log_pre_operation_data or the log_post_operation_data</p>"},{"location":"irppacket_parsing/#entropy","title":"Entropy","text":"<p>Models: Cryptolock  Unveil  ShieldFS  Redemption  RWGuard </p> <p>To compute Entropy use the shannon's formula on the Buffer of the operation.</p>"},{"location":"irppacket_parsing/#file-read","title":"File Read","text":"<p>Models: ShieldFS |  RWGuard</p> <p>The read operation has the Major code IRP_MJ_READ</p>"},{"location":"irppacket_parsing/#file-write","title":"File Write","text":"<p>Models: ShieldFS |  RWGuard</p> <p>The write operation has the Major code IRP_MJ_WRITE</p>"},{"location":"irppacket_parsing/#file-close","title":"File Close","text":"<p>Models: RWGuard</p> <p>The close operation has the Major code IRP_MJ_CLOSE</p> <p>Note: this code does not have a parameter field</p>"},{"location":"irppacket_parsing/#access-frequency","title":"Access Frequency","text":"<p>Models: Redemption</p> <p>Access frequency is the inverse of elapsed time between two write operation.</p> <p>Computes the elapsed time between two subsequent write requests generated by a single process to access two different files. </p> <p><code>Access frequency = 1/elapsed time</code></p> <p>As the elapsed time between two write requests increases, the access frequency decreases.</p> <p>By process, monitor each IRP_MJ_WRITE file name. If the file name is different take the elapsed time from the timestamps and do the difference to get the elapsed time.</p>"},{"location":"irppacket_parsing/#file-type-cross-write","title":"File type cross Write","text":"<p>Models: Redemption</p> <p>Check if the process requests write access to files that belong to different document classes.</p> <p>Use the <code>IRP_MJ_WRITE</code> to get file operations and get the file extension from the file name.</p> <p>Q: what is a document class? Q: can i extract the document class from the file path?</p>"},{"location":"irppacket_parsing/#file-type-cross-rw-file-type-funneling","title":"File type cross R/W  (File type funneling )","text":"<p>Models: Cryptolock</p> <p>Check if the number of file types in input is higher than the number of file types in output</p> <p>File in input:  <code>IRP_MJ_READ</code> and filename to extract the extension from the string File in output: <code>IRP_MJ_WRITE</code> and filename to extract the extension from the string</p>"},{"location":"irppacket_parsing/#file-type-coverage","title":"File type Coverage","text":"<p>Models: ShieldFS</p> <p>Check the percentage of accessed files by file extension</p> <p>Ordinary processes only access a small number of files by type, ransomwares try to access all of them.</p> <p>Q: What does it mean accessed? Is it a READ, a WRITE or BOTH?</p>"},{"location":"irppacket_parsing/#file-create","title":"File Create","text":"<p>Models: RWGuard</p> <p>Check the <code>IRP_MJ_CREATE</code> major code</p>"},{"location":"irppacket_parsing/#delete","title":"Delete","text":"<p>Models: Cryptolock Redemption</p> <p>Relevant codes are IRP_MJ_CREATE and IRP_MJ_SET_INFORMATION</p> <p>FileDispositionInformationEx = 64,</p> <p>Monitor if the process deletes a file</p> <p>reference</p> <p>IRP_MJ_CREATE</p> <p>For the Major code <code>IRP_MJ_CREATE</code> check the flag FILE_DELETE_ON_CLOSE</p> <p>data-&gt;Iopb-&gt;MajorFunction  ==  IRP_MJ_CREATE data-&gt;Iopb-&gt;Parameters.Create.Options == FILE_DELETE_ON_CLOSE</p> <p>IRP_MJ_SET_INFORMATION</p> <p>For the Major code <code>IRP_MJ_SET_INFORMATION</code> check if the PFILE_DISPOSITION_INFORMATION flag is of type DeleteFile</p> <p>data-&gt;Iopb-&gt;MajorFunction  == IRP_MJ_SET_INFORMATION data-&gt;Iopb-&gt;Parameters.SetFileInformation.FileInformationClass == FILE_DISPOSITION_INFORMATION</p> <p>FILE_DISPOSITION_INFORMATION.DeleteFile == True</p> <p>PROBLEMA: i file iniziano ad avere componenti diverse</p>"},{"location":"irppacket_parsing/#file-size-change","title":"File size change","text":"<p>Models: RWGuard</p> <p>Q1: how do you find the old file size? With a CREATE ? Or With a READ Q2: How do you find the new file siez? Witha WRITE ?</p> <p>https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_file_standard_information https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwqueryinformationfile</p> <pre><code>#include &lt;ntddk.h&gt;\n\nNTSTATUS GetFileSize(PFILE_OBJECT FileObject, PLARGE_INTEGER FileSize)\n{\n    NTSTATUS status;\n    IO_STATUS_BLOCK ioStatusBlock;\n    FILE_STANDARD_INFORMATION fileInfo;\n\n    if (FileObject == NULL || FileSize == NULL) {\n        return STATUS_INVALID_PARAMETER;\n    }\n\n    status = ZwQueryInformationFile(\n        FileObject,\n        &amp;ioStatusBlock,\n        &amp;fileInfo,\n        sizeof(FILE_STANDARD_INFORMATION),\n        FileStandardInformation\n    );\n\n    if (NT_SUCCESS(status)) {\n        *FileSize = fileInfo.EndOfFile;\n    }\n\n    return status;\n}\n\nvoid ExampleUsage(PDEVICE_OBJECT DeviceObject, PIRP Irp)\n{\n    PIO_STACK_LOCATION irpSp;\n    PFILE_OBJECT fileObject;\n    LARGE_INTEGER fileSize;\n    NTSTATUS status;\n\n    irpSp = IoGetCurrentIrpStackLocation(Irp);\n    fileObject = irpSp-&gt;FileObject;\n\n    if (fileObject) {\n        status = GetFileSize(fileObject, &amp;fileSize);\n        if (NT_SUCCESS(status)) {\n            DbgPrint(\"File size: %lld bytes\\n\", fileSize.QuadPart);\n        } else {\n            DbgPrint(\"Failed to get file size: %08x\\n\", status);\n        }\n    }\n\n    // Continue processing the IRP...\n}\n</code></pre>"},{"location":"irppacket_parsing/#similarity","title":"Similarity","text":"<p>Models: Cryptolock Redemption</p> <p>sdhash</p> <p>For the time being in stand-by</p>"},{"location":"irppacket_parsing/#file-type-change-file-name-change-file-move","title":"File type change / File name change / File move","text":"<p>NB for all of this we just simply observe change in the file path.</p> <p>Models: Cryptolock RWGuard</p> <ul> <li>Cryptolock: just monitor the file type change</li> <li>RW_GUARD:  Ransomwares change the file type after encryption. Monitor the file type change before and after a write operation</li> </ul> <p>IRP packet: IRP_MJ_SET_INFORMATION </p> <p>Place the capture in the <code>log_post_operation_data</code> function in the filter space. </p> <p>File rename is communicated with a <code>IRP_MJ_SET_INFORMATION</code> packet. The FLT_PARAMETERS struct associated with this IRP is is the <code>SetFileInformation</code>. This contains a <code>FILE_INFORMATION_CLASS FileInformationClass</code> enumeration with value <code>FileRenameInformation</code>. The actual values of the IRP can be accessed using the <code>PVOID InfoBuffer</code>. </p> <p>The parameter of the IRP are defined in a <code>FILE_RENAME_INFORMATION struct</code>. The value of interest are the</p> <ul> <li>ULONG FileNameLength;</li> <li>WCHAR FileName[1];<ul> <li>NB: FILE_INFORMATION_CLASS is an enumeration specifying which values are accessible through the PVOID InfoBuffer. In the pre and post function we do not access a FILE_RENAME_INFORMATION struct directly.  </li> </ul> </li> </ul> <p>To store the value we use a struct  <pre><code>struct {\nULONG FileNameLength;\nWCHAR NewName[64];\n} Filename\n</code></pre> Q: the docs says FileName[1] is the first character in memory so it should be of type WCHAR. How can I cast into a pointer?</p> <p>Todo: add memory consideration Todo: add allineation consideration</p> <p>In the filter space we copy the buffer with the wcscpy, analogus to the strcpy function. </p> <p>Likewise, to print the path on log file we use the fwprintf function. Note that the format parameter must be of type WCHAR with parameter <code>%ls</code>. Simply use <code>L\"%ls\"</code> as parameter.</p> <p>Example:</p> <p>Note: The simrep project contains some examples of the InfoBuffer</p> <pre><code>PFILE_RENAME_INFORMATION renameInfo\nrenameInfo = Cbd-&gt;Iopb-&gt;Parameters.SetFileInformation.InfoBuffer\n            setInfo.RootDirectory = renameInfo-&gt;RootDirectory;\n            setInfo.FileNameLength = renameInfo-&gt;FileNameLength;\n            setInfo.FileName = renameInfo-&gt;FileName;\n</code></pre> <p>Educated guess</p> <p>Note that the Window documentation page of IRP_MJ_SET_INFORMATION packets is inside the legacy filter technology while in this work we are using the Minifilter technology. The FileInformationClass for the legacy it is accessible through a pointer to the IRP, while for the Minifilter we use the InfoBuffer pointer.</p> <p>The documentation for the minifilter does not specifies the contents of InfoBuffer, it just states that \"it Pointer to an input buffer that contains the file information to be set\". Given the available exemples, we assume that the contents of the buffer are specified by the <code>FileInformationClass</code> associated with the operation.</p>"},{"location":"irppacket_parsing/#override-ratio","title":"Override ratio","text":"<p>Models: Redemption</p> <p>Verify which percentage of the file is overwritten.</p> <ul> <li>sA file size </li> <li>yA is the total size of the data blocks modified by the process</li> </ul> <p>Override ratio is calculated as yA/ sA </p> <p>| where the higher the number of data blocks modified by the process, the closer the value is to 1. | even if file is overwritten with the same content it counts as a overwrite. This feature does not consider the contents like similarity.</p> <p>Q: how many write operations</p>"},{"location":"irppacket_parsing/#folder-listing","title":"Folder listing","text":"<p>Description</p> <p>Models ShieldFS</p> <p>Major IRP_MJ_DIRECTORY_CONTROL Minor IRP_MN_QUERY_DIRECTORY</p> <p>Number of folder-listing operations normalized by the total number of folders in the system.</p> <p>The actual request depends on a FileInformation filed ToDO: cl</p> FileInformationClass Description FileBothDirectoryInformation FILE_BOTH_DIR_INFORMATION struct for each file. FileDirectoryInformation FILE_DIRECTORY_INFORMATION struct for each file. FileFullDirectoryInformation FILE_FULL_DIR_INFORMATION struct for each file. FileIdBothDirectoryInformation FILE_ID_BOTH_DIR_INFORMATION struct for each file. FileIdFullDirectoryInformation FILE_ID_FULL_DIR_INFORMATION struct for each file. FileNamesInformation FILE_NAMES_INFORMATION struct for each file. FileObjectIdInformation FILE_OBJECTID_INFORMATION struct for each file. FileReparsePointInformation single FILE_REPARSE_POINT_INFORMATION struct for the directory."},{"location":"irppacket_parsing/#directory-traversal","title":"Directory Traversal","text":"<p>Models Redemption</p> <p>Redemption monitors if the process traverses over the user files with write privilege, and computes the additive inverse of the number of privileged accesses to unique files in a given path. </p>"},{"location":"irppacket_parsing/#temporary-files","title":"Temporary Files","text":"<p>Models RWGuard</p>"}]}